## 一.Looper
1. 构造方法

    ```
    private Looper(boolean quitAllowed) {
        mQueue = new MessageQueue(quitAllowed);
        mThread = Thread.currentThread();
    }
    
    Looper的构造方法被私有，主要是做了两件事
    1.创建一个消息队列
    2.获取当前线程
    ```

2. prepare

   ```
   1.prepare对外提供了一个无参方法，会调用内部有参方法
   public static void prepare() {
   	prepare(true);
   }
   
   2.通过第9行的判断，可以看到只能prepare一次
   3.prepare的作用是创建一个Looper对象，并存到sThreadLocal
   private static void prepare(boolean quitAllowed) {
   	if (sThreadLocal.get() != null) {
   		throw new RuntimeException("Only one Looper may be created per thread");
       }
           sThreadLocal.set(new Looper(quitAllowed));
       }
   }
   ```

3. prepareMainLooper和getMainLooper

   ```
   将当前线程初始化为looper，并将其标记为application的main looper
   
   这个方法会在ActivityThread的main方法调用
   ```

4. loop

   * 好了，通过prepare方法，我们创建了looper对象，也就是说我们创建了一个消息队列，那么接下来我们如果使用这个消息队列呢？

   ```
   1.我们首先通过sThreadLocal拿到looper对象，进而获取到消息队列
   final Looper me = myLooper();
   if (me == null) {
       throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
   }
   final MessageQueue queue = me.mQueue;
   
   2.首先清除标识来确保这个线程的标识是本地进程的标识，然后获取本地进程的标识
   Binder.clearCallingIdentity();
   final long ident = Binder.clearCallingIdentity();
   关于clearCallingIdentity方法，binder driver会判断当前的Binder调用是否为远程调用，如果是同进程调用的话，binder driver就不会再向应用提供进程的PID和UID。将会在下一篇详细分析Binder机制
   
   3.循环处理消息队列
   派发消息，msg.target就是Handler
   msg.target.dispatchMessage(msg);
   
   msg.recycleUnchecked();
   ```


## 二.Handler

```
1.构造方法
对mLooper,mQueue,Mcallback,mAnonymous四个变量赋值

2.sendMessage,sendEmptyMessage都是调用sendMessageAtTime，然后调用enqueueMessage
可以看出sendMessage的本质是对MessageQueue的enqueueMessage方法的封装
sendMessage其实就是经过一系列操作，将消息插入到队列。
那么消息派发在哪呢，还记得Looper.loop()里的msg.target.dispatchMessage(msg)吗？对，就是在这派发的。msg.tartget就是Handler

3.dispatchMessage
定义了一套消息处理的优先级机制
1.Message如果自带了callback，则交给callback
2.Handler构造时，如果传入了callback，则交给传入的callback
3.如果以上都没有，则交由handleMessage(Message msg)处理，这个方法是空实现，一般我们采用第三种方法，然后在子类重写handleMessage方法
```



## 三.HandlerThread

```
本质上是一个Thread，内部封装了Looper.prepare()和Looper.loop(),同时运用wait/notifyAll避免looper为空的问题

1.构造方法
两个方法，这个没什么好说的，重点来看run和getLooper

2.getLooper
这里注释已经写得很清楚了，通过wait来确保mLooper已经被创建
public Looper getLooper() {
    if (!isAlive()) {
        return null;
    }
    
    // If the thread has been started, wait until the looper has been created.
    synchronized (this) {
        while (isAlive() && mLooper == null) {
            try {
                wait();
            } catch (InterruptedException e) {
            }
        }
    }
    return mLooper;
}

3.run
我们可以看到在run方法里调用了Looper.prepare()和Looper.loop()
给了一个onLooperPrepared方法，我们可以重写该方法，在该方法里做一些操作
Looper.prepare()后notifyAll，此时getLooper中返回的mLooper一定已经被创建
public void run() {
    mTid = Process.myTid();
    Looper.prepare();
    synchronized (this) {
        mLooper = Looper.myLooper();
        notifyAll();
    }
    Process.setThreadPriority(mPriority);
    onLooperPrepared();
    Looper.loop();
    mTid = -1;
}
```

